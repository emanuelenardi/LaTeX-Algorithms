%&../settings/preamble.main

\ifsubfile
\usepackage[newfloat, cachedir=_minted-cache, outputdir=../build]{minted}
\usepackage{../libraries/set-minted}

\pagestyle{plain}
\setcounter{chapter}{2}

% arara: pdflatex: { options: ["--output-directory=../build"], shell: yes, draft: yes, synctex: no }
% arara: pdflatex: { options: ["--output-directory=../build"], shell: yes, synctex: no }
\begin{document}
\fi
\section{Algoritmo della somma massimale di un sottovettore}

Date le nostre nuove conoscenze possiamo calcolare con precisione la complessità delle varie versioni degli algoritmi proposti per la soluzione al problema della somma massimale di un sottovettore.

\subsubsection*{Complessità della prima versione}

\begin{code}
\begin{minted}{cpp}
int maxsum1(int[] A, int n) {
	int maxSoFar = 0;
	for (int i = 0; i < n; i++) {
		for (int j = i; j < n; j++) {
			int sum = 0;
			for (int k = i; k <= j; k++) {
				sum = sum + A[k];
			}
			maxSoFar = max(maxSoFar, sum);
		}
	}
	return maxSoFar;
}
\end{minted}
% \captionof{listing}{Versione 1}
% \label{code:c-code}
\end{code}

La complessità dell'algoritmo può essere approssimata come segue (contando il numero di esecuzioni della riga più interna):
\[\begin{WithArrows}[displaystyle]
T(n) = \sum_{i=0}^{n-1} \sum_{j=i}^{n-1} (j - i + 1)
\end{WithArrows}\]

Vogliamo provare che \(T(n) = \Omicron(n^3)\).
\begin{proof}
\textbf{limite superiore}:
\(\exists c_2 > 0, \exists m \geqslant 0 : T(n) \leqslant c_2 n^3\), \(\forall n \geqslant m\).
\[\begin{WithArrows}[displaystyle]
T(n) &= \sum_{i=0}^{n-1} \sum_{j=i}^{n-1} (j - i + 1) \Arrow{spiegazione}\\
	 &\leqslant \sum_{i=0}^{n-1} \sum_{j=i}^{n-1} n \Arrow{spiegazione}\\
	 &\leqslant \sum_{i=0}^{n-1} \sum_{j=0}^{n-1} n \Arrow{spiegazione}\\
	 &=\sum_{i=0}^{n-1} n^2 \Arrow{spiegazione}\\
	 &= n^3 \leqslant c_2 n^3
\end{WithArrows}\]
Questa disequazione è vera per \(n \geqslant m = 0\) and \(c_2 \geqslant 1\).
\end{proof}

Vogliamo provare che \(T(n) = \Omega(n^3)\).
\begin{proof}
\textbf{limite inferiore}:
\(\exists c_1 > 0, \exists m \geqslant 0 : T(n) \leqslant c_1 n^3\), \(\forall n \geqslant m\).
\[\begin{WithArrows}[displaystyle]
T(n) &= \sum_{i=0}^{n-1} \sum_{j=i}^{n-1} (j - i + 1) \\
	 &\geqslant \sum_{i=0}^{\nicefrac{n}{2}} \sum_{j=i}^{n+\nicefrac{n}{2}-1} (j - i + 1) \Arrow{spiegazione}\\
	 &= \sum_{i=0}^{\nicefrac{n}{2}} \sum_{j=i}^{n+\nicefrac{n}{2}-1} \nicefrac{n}{2} \Arrow{spiegazione}\\
	 &= \sum_{i=0}^{\nicefrac{n}{2}} \nicefrac{n^2}{4} \geqslant \nicefrac{n^3}{8} \geqslant c_1 n^3
\end{WithArrows}\]
Questa disequazione è vera per \(n \geqslant m = 0\) and \(c_1 \geqslant 8\).
\end{proof}

\subsubsection*{Complessità della seconda versione}

\begin{code}
\begin{minted}{cpp}
int maxsum2(int[] A, int n) {
	int maxSoFar = 0;
	for (int i=0; i < n; i++) {
		int sum = 0;
		for (int j=i; j < n; j++) {
			sum = sum + A[j];
			maxSoFar = max(maxSoFar, sum);
		}
	}
	return maxSoFar;
}
\end{minted}
% \captionof{listing}{Versione 2}
% \label{code:version-2}
\end{code}

La complessità di questo algoritmo può essere approssimata come segue (stiamo contando il numero di passi nel ciclo più interno):
\[\begin{WithArrows}[displaystyle]
T(n) = \sum_{i=0}^{n-1} n-i
\end{WithArrows}\]

Vogliamo provare che \(T(n) = \Theta(n^2)\)

\begin{proof}
\[\begin{WithArrows}[displaystyle]
T(n) &= \sum_{i=0}^{n-1} n-i \Arrow{spiegazione}\\
     &= \sum_{i=1}^{n} i \Arrow{spiegazione}\\
     &= \frac{n (n + 1)}{2} = \Theta(n^2)
\end{WithArrows}\]
Questo non richiede ulteriori spiegazioni.
\end{proof}

\subsubsection*{Complessità della terza versione}

\begin{code}
\begin{minted}{cpp}
int maxsum_rec(int[] A, int i, int j) {
    if (i == j)
      return max(0, A[i]);

    int m = (i + j) / 2;
    int maxs = maxsum_rec(A, i, m);
    int maxd = maxsum_rec(A, m + 1, j);
    int maxss = 0;
    int sum = 0;

    for (int k = m; k >= i; k--) {
      sum = sum + A[k];
      maxss = max(maxss, sum);
    }

	int maxdd = 0;
    sum = 0;
    for (int k = m + 1; k <= j; k++) {
      sum = sum + A[k];
      maxdd = max(maxdd, sum);
    }

    return max(max(maxs, maxd), maxss + maxdd);
}
\end{minted}
% \captionof{listing}{Versione 3}
% \label{code:version-3}
\end{code}

Per questo, definiamo la equazione di ricorrenza:
\[\begin{WithArrows}[displaystyle]
T(n) = 2T(\nicefrac{n}{2}) + n
\end{WithArrows}\]
Utilizzando il teorema, possiamo vedere che \(\alpha = \log_2 2 = 1\) e \(\beta = 1\), quindi \(T(n) = \Theta(n \log n)\).

\subsubsection*{Complessità della quarta versione}

\begin{code}
\begin{minted}{cpp}
int maxsum4(int A[], int n) {
	int maxSoFar = 0;
	int maxHere = 0;
	for (int i = 0; i < n; i++) {
		maxHere = max(maxHere + A[i], 0);
		maxSoFar = max(maxSoFar, maxHere);
	}

	return maxSoFar;
}
\end{minted}
% \captionof{listing}{Versione 4}
% \label{code:version-4}
\end{code}

\`{E} facile vedere che la complessità di questa versione è \(\Theta(n)\).

\ifsubfile
\end{document}
\fi
